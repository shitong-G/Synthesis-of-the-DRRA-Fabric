# 向量加法测试验证指南

## 📋 测试概述

**测试目标：** 在 DPU<0,0> 中执行向量加法操作

**测试内容：**
- 从 SRAM 加载两个向量
- 在 DPU 中执行向量加法
- 检查输出结果

## 🔍 验证步骤

### 步骤1：检查仿真是否完成

✅ **检查点：**
- 仿真运行到至少 `10000ns`（根据 `const_package.vhd`，总执行周期是72，时钟周期12ns，需要至少 `72 * 12 = 864ns`）
- 没有 fatal 错误
- 只有警告（可以忽略除0警告）

### 步骤2：检查时钟和复位

✅ **在波形中检查：**
```
信号：/testbench/clk
- 应该是周期性的方波（周期 12ns）
- 从 0ns 开始

信号：/testbench/rst_n
- 0ns-4ns: 应该是 '0'（复位）
- 4ns 之后: 应该是 '1'（释放复位）
```

### 步骤3：检查指令加载

✅ **检查指令加载过程：**
```
信号：/testbench/instr_load
- 在复位释放后（4ns之后），应该出现多个脉冲
- 每个脉冲对应一条指令加载

信号：/testbench/instr_input
- 在 instr_load='1' 时，应该显示指令内容（十六进制）
- 应该有 27 条指令（根据 instruction.bin）
```

**预期时间线：**
- 0-4ns: 复位阶段
- 4ns-37*12ns (约444ns): 内存和寄存器初始化 + 指令加载
- 444ns之后: 执行阶段

### 步骤4：检查 DPU 输入数据

✅ **检查 DPU 输入（在 DPU<0,0>）：**
```
信号：dpu_in_0, dpu_in_1, dpu_in_2, dpu_in_3
- 在执行阶段，这些信号应该从 'X' 变为有效数据
- 数据应该是 16 位有符号数（十进制显示）
```

**内存初始化数据（参考）：**
根据 `testbench.vhd` 第 71-74 行：
- 地址 0: `0x000f000e000d000c000b000a0009000800070006000500040003000200010000`
  - 向量1: [0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f]
  - 十进制: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]

- 地址 1: `0x001f001e001d001c001b001a0019001800170016001500140013001200110010`
  - 向量2: [0x0010, 0x0011, ..., 0x001f]
  - 十进制: [16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]

### 步骤5：检查 DPU 输出结果 ⭐ **最重要**

✅ **检查 DPU 输出（关键验证点）：**

```
信号：dpu_out_0 和 dpu_out_1
位置：/testbench/DUT/MTRF_COLS(0)/MTRF_ROWS(0)/.../dpu_gen/dpu_out_0
```

**预期结果：**

如果测试是向量加法：`result = vector1 + vector2`

**预期输出序列（十进制）：**
- dpu_out_0: 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46
  - 计算：0+16=16, 1+17=18, 2+18=20, ..., 15+31=46

**检查要点：**
1. ✅ 输出不是 'X'（未初始化）
2. ✅ 输出不是 'U'（未定义）
3. ✅ 输出是有效的数字
4. ✅ 输出值符合预期（向量加法结果）
5. ✅ 输出在正确的时钟周期出现（执行阶段）

### 步骤6：检查时序

✅ **检查执行时序：**
- 指令加载应该在复位后开始
- DPU 输出应该在指令执行后出现
- 输出应该有稳定的值（不是一直变化）

## 📊 预期结果总结

### 成功标准：

1. ✅ **仿真完成**：没有 fatal 错误
2. ✅ **复位正常**：rst_n 在 4ns 后变为 '1'
3. ✅ **指令加载**：27 条指令成功加载
4. ✅ **数据输入**：DPU 输入有有效数据
5. ✅ **输出正确**：DPU 输出符合向量加法结果

### 失败情况：

❌ **如果输出全是 'X'：**
- 检查 `instruction.bin` 是否存在
- 检查仿真时间是否足够（至少 10000ns）
- 检查复位序列是否正确

❌ **如果输出是 'U'：**
- 检查设计是否正确编译
- 检查信号路径是否正确

❌ **如果输出值不正确：**
- 检查指令是否正确加载
- 检查内存初始化是否正确
- 检查 DPU 配置是否正确

## 🔧 调试技巧

### 1. 添加更多信号到波形

如果需要更详细的调试，可以在 `simulate_working.do` 中添加：
```tcl
# 添加内存相关信号
add wave -divider "Memory"
add wave /testbench/tb_en
add wave -radix hexadecimal /testbench/tb_inp

# 添加寄存器文件信号
add wave -divider "Register File"
# ... 添加相关信号
```

### 2. 检查特定时间点

在 QuestaSim 中：
- 使用时间游标定位到特定时间
- 检查该时间点的所有信号值

### 3. 使用断言

可以在 testbench 中添加断言来自动检查结果。

## 📝 验证清单

- [ ] 仿真运行完成（无 fatal 错误）
- [ ] 时钟信号正常（12ns 周期）
- [ ] 复位序列正确（0-4ns 复位，之后释放）
- [ ] 指令加载成功（27 条指令）
- [ ] DPU 输入有有效数据
- [ ] DPU 输出不是 'X' 或 'U'
- [ ] DPU 输出值符合预期（向量加法结果）
- [ ] 输出时序正确

## 💡 提示

1. **使用十进制显示**：在波形窗口中，右键点击信号 → Radix → Decimal，更容易查看数值
2. **放大波形**：使用 `wave zoom full` 查看完整波形
3. **定位关键时间**：找到第一个非 'X' 的输出值，检查该时间点的所有相关信号
4. **对比预期**：手动计算几个输出值，与波形中的值对比

现在可以开始验证了！

